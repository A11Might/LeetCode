/**
 * @author qhhu
 * @date 2019/12/6 - 15:09
 *
 * [264] 丑数 II
 *
 * 题目: 返回第 n 个丑数, 1是第一个丑数
 *      (丑数就是指包含质因数2, 3, 5的正整数)
 *
 * 难度: medium
 *
 * 思路: 丑数的质因子只有2, 3和5，所以每个丑数都是由一个较小的丑数乘以2, 3和5所得, 从小到大按顺序存储乘积所得丑数即可
 */
class Solution {
    /**
     * 时间复杂度: O(n)
     * 空间复杂度: O(n)
     */
    public int nthUglyNumber(int n) {
        if (n < 7) {
            return n;
        }
        int[] dp = new int[n];
        dp[0] = 1; // 第一个丑数
        // 每个丑数都是由一个较小的丑数乘以2, 3和5所得
        // a, b, c分别代表那个未乘以2, 3, 5的较小的丑数
        // 当当前丑数等于a乘以2或b乘以3或c乘以5后, 将a或b或c表示的较小的丑数移到下一个丑数上
        // 比如, 第一个较小的丑数都是dp[0] == 1, a == b == c 代表的是1这个丑数
        //             a         b         c
        //        (2 * 1)    3 * 1     5 * 1  第二个丑数就是其中最小的 2, 由于使用的是a, 所以a将代表的下一个丑数即2
        //         2 * 2    (3 * 1)    5 * 1  第三个丑数就是其中最小的 3, 由于使用的是b, 所以b将代表的下一个丑数即2
        //        (2 * 2)    3 * 2     5 * 1  以此类推
        int a = 0, b = 0, c = 0;
        for (int i = 1; i < n; i++) {
            dp[i] = Math.min(dp[a] * 2, Math.min(dp[b] * 3, dp[c] * 5));
            if (dp[i] == dp[a] * 2) a++;
            if (dp[i] == dp[b] * 3) b++;
            if (dp[i] == dp[c] * 5) c++;
        }

        return dp[n - 1];
    }
}
