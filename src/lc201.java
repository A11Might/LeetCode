/**
 * [201] 数字范围按位与
 * 
 * 题目：返回给定范围内所有数字的按位与（包含 m, n 两端点）
 *      （给定范围 [m, n]，其中 0 <= m <= n <= 2147483647）
 * 
 * 难度：medium
 * 
 * 思路：答案为 m 和 n 从高位到低位的过程中第一次出现不一样的位置之前的二进制的累积和。
 *      因为出现了第一次不一样之后，从 m 上升到 n 的过程中，必定会经历 xxx100000... 和 xxx011111...的一次变化，这次变化会将该位之后的所有数字按位与清零
 */
class Solution {
    /**
     * 时间复杂度：O(logn)
     * 空间复杂度：O(1)
     */
    public int rangeBitwiseAnd(int m, int n) {
        int ans = 0;
        for (int i = 30; i >= 0; i--) { // 都是正数不用考虑符号位
            if ((m >> i & 1) != (n >> i & 1)) break; // 从高位到低位的过程中第一次出现不一样的位置
            if ((m >> i & 1) == 1) ans += 1 << i; // 计算二进制的累积和
        }
        return ans;
    }
}