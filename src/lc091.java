/**
 * @author qhhu
 * @date 2019/11/7 - 9:53
 *
 * [91] 解码方法
 *
 * 题目：给定一个只包含数字的非空字符串，请计算解码方法的总数。
 *      (一条包含字母 A-Z 的消息通过以下方式进行了编码: 'A' -> 1; 'B' -> 2 ... 'Z' -> 26)
 *
 * 难度：medium
 *
 * 思路：划分型动态规划：将给定字符串划分为 k 段。
 *      状态表示：dp[i] 表示以 i 位置开头至字符串结尾的子串的解码总数。
 *      状态转移方程：由题意可知可以划分出一个字符或两个字符，所以状态转移方程为：dp[i] = dp[i + 1] + dp[i + 2]。
 *      初始状态：解码空字符串有一种方法。
 */
class Solution {
    /**
     * 时间复杂度：O(n)
     * 空间复杂度：O(n)
     */
    public int numDecodings(String s) {
        int len = s.length();
        int[] dp = new int[len + 1];
        // 决策边界
        // 关键：
        // 当字符串只有一个时，将 i 位置字符作为一个编码，此时 f(i) = f(i + 1)，若不设置 i + 1 的 dp 值，则无法求出这种情况。
        // 当字符串只有两个时，将 i 或者 将 i 和 i + 1 位置字符作为一个编码，此时 f(i) = f(i + 1) + f(i + 2)，若不设置 i + 2 的 dp 值，则无法求出这种情况。
        // 所以要多设置一个 dp 值，用来处理边界条件。
        dp[len] = 1;

        // 状态转移
        for (int i = len - 1; i >= 0; i--) {
            // 当前字符串其实字符为 ‘0’ 时需特殊考虑，‘0’ 不可以解码，‘01’ 也不可解码
            if (s.charAt(i) == '0') continue;
            // 将从i开始到结尾的子串的第一个数字单独解码
            dp[i] += dp[i + 1];
            if (i + 1 < len && Integer.valueOf(s.substring(i, i + 2)) <= 26) {
                // 将从i开始到结尾的子串的前两个数字单独解码
                dp[i] += dp[i + 2];
            }
        }

        return dp[0];
    }
}